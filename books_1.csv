x,y,page_number,book_name,summary,labels
95.74366,18.42618,12,EN-SCI-271-06.pdf,"The text provides a comprehensive overview of the Robot Operating System (ROS), a flexible and scalable framework for creating robot software. It is designed to be lightweight and easily integrated with other software frameworks. It is language-independent, meaning it can be implemented in any modern programming language, with Python, C++, and Lisp being the most commonly used. However, it is not designed to be a real-time framework, but it can be integrated with real-time systems.

The ROS operates on a runtime ""graph"" which is a peer-to-peer network of processes that are loosely coupled using the ROS communication infrastructure. The fundamental concepts of the ROS implementation are nodes, messages, topics, and services. Nodes are software processes that perform computation and represent a software module or component. They communicate with each other by passing messages, which are strictly typed data structures. This communication system provides several benefits to the overall system, including increased fault tolerance and easier encapsulation of implementation details.

The data exchange between nodes in ROS follows a publisher/subscriber pattern. A node sends out a message by publishing it to a topic, which is a name that identifies a particular message flow. A node can subscribe to a topic to receive this message. There may be multiple concurrent publishers and subscribers for a single topic, and a single node may publish and/or subscribe to multiple topics. Topics are intended for unidirectional, streaming communication. Nodes that need to perform remote procedure calls, i.e. receive a response to a request, should use services instead.

The text also discusses services, which are used for request/reply interactions. A service is defined by a pair of messages, one for the request and another one for the reply. A ROS node offers a service under a service name. The call from the client is blocking, meaning the node waits for the reply. Services are defined in service files, which are compiled to automatically generate a stub implementation of the service. The text also introduces the Master, which provides name registration and enables individual ROS nodes to locate one another. The Parameter Server is a shared, multi-variate dictionary that is accessible via network APIs. Nodes use this server to store and retrieve parameters at runtime. Lastly, the text mentions Bags, which is a format for saving and playing back ROS messages.

The text also discusses various libraries and tools available in ROS. The tf library is used to represent transformations between coordinate frames over time. This library allows users to transform points, vectors, etc., between any two coordinate frames at any desired point in time. It is designed to provide a standard way to keep track of coordinate frames and transform data within an entire system. However, the complexity of this task often leads to bugs when developers improperly apply transforms to data.

The text then moves on to discuss RVIZ, the 3D visualization tool in ROS. This tool supports a variety of data types and allows users to select the appropriate configuration for each specific robot. Users can also customize the RVIZ interface by developing application-specific plugins. The text also mentions other useful libraries that integrate with ROS, such as the Gazebo simulator, which is a 3D indoor and outdoor multi-robot simulator with dynamic and kinematic physics.

The Point Cloud Library (PCL) is another perception library focused on the manipulation and processing of three-dimensional data and depth images. It provides many point cloud algorithms, including filtering, feature detection, registration, kd-trees, octrees, sample consensus, and more. OpenCV, the premier computer vision library, is also integrated with ROS and provides many common computer vision algorithms and utilities. Lastly, the text mentions MoveIt!, a motion planning library that offers efficient, well-tested implementations of state-of-the-art planning algorithms. It can be used with any ROS-supported robot and planning data can be visualized with rviz and rqt plugins.",1
20.955297,-21.129482,170,numpy-user.pdf,"The text provides a comprehensive guide on the use of NumPy, a Python library used for working with arrays. It begins by discussing the numpy.dtype object, explaining that it can be defined in several ways, including a sequence of tuples (name, type), an existing numpy.dtype object, or the special value None. The dtype output will be a 1D array with a structured dtype, which has as many fields as items in the sequence. The field names are defined with the names keyword. 

The text then delves into the use of the names argument, explaining that when dealing with tabular data, it is common to allocate a name to each column. This can be done using an explicit structured dtype or the names keyword with a sequence of strings or a comma-separated string. The names can also be defined from the data itself by using the names keyword with a value of True. 

The text also discusses the defaultfmt argument and the validation of names. If names=None but a structured dtype is expected, names are defined with the standard NumPy default of ""f%i"", yielding names like f0, f1, and so forth. This default can be overwritten with the defaultfmt argument. 

The text then moves on to discuss the use of NumPy, explaining how to use the array of npy_intp variables, PyArray_STRIDES (obj), which shows how many bytes must be added to the current element pointer to get to the next element in each dimension. It also mentions the use of PyArray_GETPTR{k} (obj, . . . ) macros for arrays less than 4-dimensions. The text further explains the striding patterns of C-style contiguous arrays and Fortran-style contiguous arrays, and how to test whether the striding pattern of a particular array matches these styles.

The text provides an example of how to write a wrapper that accepts two input arguments and an output argument. The function returns None and updates the output array. The example includes a code snippet that demonstrates how to use the WRITEBACKIFCOPY semantics for NumPy v1.14 and above. The code snippet also shows how to handle errors and clean up resources.

The text concludes by discussing the use of Python as a glue language, particularly in scientific computing. It explains how Python was initially used to glue together large application codes running on supercomputers, and how the development of Numeric into NumPy has allowed more code to be written directly in NumPy. 

The text then provides a tutorial on how to use NumPy, explaining how to access elements in an array using indexing. It provides an example of creating an array using the arange function and reshaping it into a 3x5 matrix. The tutorial also explains how to check the shape, dimension, data type, item size, and type of the array. It then demonstrates how to create another array using the array function.

The tutorial continues by explaining different ways to create arrays. It shows how to create an array from a regular Python list or tuple using the array function, and how to specify the data type of the array at creation time. It also explains how to create arrays with initial placeholder content using the zeros, ones, and empty functions. The tutorial then demonstrates how to create sequences of numbers using the arange and linspace functions. 

The tutorial concludes by explaining how to print arrays. It describes the layout of printed arrays, where the last axis is printed from left to right, the second-to-last from top to bottom, and the rest from top to bottom with each slice separated by an empty line. It also explains how NumPy automatically skips the central part of the array and only prints the corners if the array is too large to be printed. However, this behavior can be disabled and NumPy can be forced to print the entire array by changing the printing options using the set_printoptions function.",0
6.1846147,61.96834,34,numpy_tutorial.pdf,"The text provides an in-depth exploration of the NumPy library in Python, a programming language. NumPy, short for 'Numerical Python', is a library that supports large, multi-dimensional arrays and matrices, and includes a vast collection of high-level mathematical functions to operate on these arrays. The library was developed by Jim Hugunin and later enhanced by Travis Oliphant in 2005, who integrated features of another package, Numarray, into NumPy. It is often used in conjunction with other packages like SciPy and Matplotlib as an alternative to MatLab, a widely used platform for technical computing.

The first section of the text explains how to define structured data types in NumPy. It provides examples of how to create an array with a single integer field 'age', and another array with three fields - 'name' (a string), 'age' (an integer), and 'marks' (a float). The author also provides a list of character codes that uniquely identify built-in data types in NumPy, such as 'b' for boolean, 'i' for signed integer, 'f' for floating-point, and so on.

The second section delves into array attributes in NumPy. It explains how to use the .shape attribute to get the dimensions of an array and to resize an array. The .ndim attribute is used to get the number of array dimensions. The author also introduces the .itemsize attribute, which returns the length of each element of an array in bytes. The .flags attribute is used to get information about the memory layout of the array.

The final part of the text explains how to create a new ndarray object using the numpy.empty function. This function creates an uninitialized array of a specified shape and data type. The author provides an example of how to use this function to create a 3x2 array of integers.

The text also provides information on how to install NumPy. Since the standard Python distribution does not come with NumPy, it must be installed separately. This can be done using pip, a popular Python package installer, or by installing a binary package specific to the user's operating system, which includes the full SciPy stack along with NumPy. The text provides specific installation instructions for different operating systems, including Windows and Linux, and mentions several Python distributions that come with SciPy stack, such as Anaconda, Canopy, and Python (x,y).

The text introduces the ndarray object, the most important object in NumPy. An ndarray, or N-dimensional array, is a collection of items of the same type that can be accessed using a zero-based index. Each item in an ndarray takes up the same size block in memory and is an object of a data-type object, or dtype. The ndarray can be created using various array creation routines, or by using the numpy.array function. The text provides the syntax for importing the NumPy package and creating an ndarray.

The text appears to be a table of contents or an index from a book or manual about NumPy. It lists various NumPy functions related to array manipulation, binary operators, string functions, mathematical functions, arithmetic operations, statistical functions, and sort, search, and counting functions. These functions are used for a variety of purposes, such as changing the structure of arrays, performing bitwise operations on arrays, performing element-wise arithmetic operations on arrays, performing statistical analysis on arrays, and sorting arrays, searching for elements in arrays, and counting occurrences of elements in arrays.",0
-62.729084,-9.852992,172,pandas.pdf,"The text provides a comprehensive guide on how to use the pandas library in Python for data manipulation and analysis. It begins with an explanation of the pivot_table function, which is used to create a spreadsheet-style pivot table as a DataFrame. The text provides examples of how to use the function with different parameters and options, such as using the index as 'Position' and the columns as 'City', with the values in the table being 'Age' and the aggregate function used being 'sum'. It also explains how to handle non-numeric data by using the 'Name' column as the values and using aggregate functions like 'first', 'last', 'sum', and 'join'.

The text then delves into how to use the pivot_table function with multiple columns in the index, columns, and values parameters, and how to use multiple aggregate functions in a single pivot table. It also explains how to apply specific functions to specific columns by creating a new column 'Random' with random values and using it in the pivot_table function. It also shows how to pass a list of functions to apply to the individual columns.

The text then moves on to explain the stack and unstack functions in pandas, which are used to ""compress"" and ""expand"" a level in the DataFrame's columns respectively. It provides a detailed explanation of various operations that can be performed on data using Python's pandas library, such as creating a new column in a DataFrame by performing operations on existing columns, locating and replacing data in a DataFrame, adding a new row to a DataFrame, deleting or dropping rows from a DataFrame, and reordering the columns in a DataFrame.

The text also covers string manipulation in pandas, explaining how to extract and replace strings using regular expressions, and how to slice strings. It also explains how pandas handles indices and slices that are out of range.

The text is essentially a table of contents for a book about pandas, a software library written for the Python programming language for data manipulation and analysis. The book is divided into 23 chapters, each focusing on a different aspect of using pandas, from getting started and performing basic functions, to data analysis, appending to DataFrame, Boolean indexing of dataframes, handling categorical data, computational tools, creating DataFrames, selecting cross-sections, checking and changing data types, handling duplicated data, getting DataFrame information and memory usage, detecting missing values, graphing and visualizations, grouping data and time series data, holiday calendars, indexing and selecting data, IO for Google BigQuery, JSON, making pandas play nice with native Python datatypes, mapping values, and merging, joining, and concatenating.",2
-15.300817,-97.53686,720,RobotOS.pdf,"The text provides a comprehensive overview of various experiments and developments in the field of robotics, particularly focusing on navigation and perception. It begins by detailing an experiment where a robot, controlled by a simple node and using ROS Navigation, was tasked with moving from an initial to a final position in a room. The robot's success in navigating to the goal, avoiding obstacles, and adjusting its angle upon reaching the goal is highlighted. Two specific scenarios are described - one where the robot navigates in a straight line to the goal, avoiding an obstacle and its surrounding region, known as the inflation radius, and another where the robot navigates through a corridor, avoiding multiple obstacles to reach the goal. The text emphasizes the importance of the overlap between obstacles on the gmapping map and on the CostMaps, and the challenges of navigating through unknown environments.

The text then introduces the LIDA (Learning Intelligent Distribution Agent) Framework, a Java implementation of a cognitive model of artificial consciousness, and its application in robotics. A tutorial on building a cognitive robotic system using this framework is presented, along with the introduction of a new ROS module, the LIDA Bridge, designed to facilitate this development. The authors also provide a brief biography of Walter Fetter Lages, an associate professor with a background in Electrical and Computer Engineering, and discuss recent advancements in service robotics, including the development of robots for human environments and accessibility, and the challenges of navigating dynamic environments.

The final part of the text discusses the SPENCER project, which involved the development of a mobile data capture platform and a people tracking pipeline. The platform, built using an off-the-shelf bicycle trailer equipped with sensors, was used to capture over 1.4 TB of data at a major European airport to train the robot's perception components. The people tracking pipeline, developed to detect and track people and groups in real-time, starts with sensory data such as 2D laser scans, RGB-D point clouds, or stereo or monocular camera images. The text explains the complexity of combining information from multiple detectors operating on different sensor modalities, and the use of the RViz visualization tool and custom plugins to visualize the outputs of the tracking pipeline. The passage concludes by discussing the detection of people using RGB-D and 2D laser range data, and presents message definitions for person detection.",1
82.25022,-79.62724,293,ros.pdf,"The book provides a comprehensive guide on the fundamentals of programming languages, specifically C++ and Python, and their application in Ubuntu Linux for robotics programming. It begins with an in-depth discussion on the C++ programming language, explaining its compiler in Ubuntu and the process of compiling a C++ file. It further delves into the object-oriented concepts in C++, highlighting the differences between C++ classes and structs in C, and important programming concepts such as access modifiers and inheritance. The chapter also covers file operations, namespaces, exception handling, and the Standard Template Library in C++. It concludes by explaining how to compile C++ source code using Linux makefiles and CMakeLists.txt files.

The book then transitions to Python programming in Ubuntu Linux, explaining that C++ and Python are the common languages used in robotics programming. The choice between the two depends on the preference for performance (C++) or ease of programming (Python). The chapter also discusses the trade-off between performance and development time when choosing a programming language for robotics applications. It provides a brief history of Python, highlighting its design philosophy of code readability and syntax, and its common use in robotics applications where less computation is required.

The book provides a detailed guide on programming Python in Ubuntu Linux, explaining that like the GNU C/C++ compiler, the Python interpreter is preinstalled in Ubuntu. It provides instructions on how to open the default Python version interpreter and how to get a list of the installed Python versions. It also explains the different Python commands for two different versions of Python: 2.7.12 and 3.5.2. The chapter concludes by providing instructions on how to manually install Python on Ubuntu 16.04 LTS and how to verify the Python installation.

The book then discusses the programming of robots using the Robot Operating System (ROS). It begins by explaining how to install ROS on a Raspberry Pi, a small, affordable computer that can be used to learn programming. The chapter then delves into the creation of a ROS workspace, the creation of a ROS package, and how to write ROS nodes using C++ and Python. It also discusses ROS launch files and how to include nodes in a launch file. The chapter provides examples of working with turtlesim in ROS and a Gazebo simulation of TurtleBot. It concludes by discussing how to program embedded boards such as the Arduino and the Raspberry Pi using ROS, which is useful when creating robots.

The book then discusses the creation of wheeled robot hardware and software using ROS. It explains how to apply the programming concepts learned in the previous chapter to a real robot. The reader is guided on how to make a low-cost, differential drive robot that is compatible with ROS and how to perform dead reckoning in the robot using ROS. The chapter emphasizes the need for a clear understanding of the previous five chapters to successfully complete the project. It also outlines how to assemble the robot hardware, interface sensors using Arduino, interface a ROS PC and a robot using a Bluetooth interface, create a robot model in ROS, and write nodes to move the robot and perform dead reckoning.

The book then delves into the specifics of wheeled robots, which are a popular category of mobile robots. It explains that differential drive is the most common and simple type of configuration used in wheeled robotics. The chapter guides the reader on how to build differential drive robot hardware and write software to interface with ROS. It also discusses differential drive robot kinematics, explaining how to build a differential wheeled robot and how adjusting the speed of the motor moves the robot in different directions. The chapter concludes by explaining how to calculate the exact position and orientation of the robot from the wheel speed using a sensor called wheel encoders.

The book provides a detailed guide on how to use Ubuntu Linux for robotics, focusing on the installation of software applications and the use of command-line interface (CLI). The Ubuntu Software, accessible through the Unity Launcher, is the direct way to install applications. However, for advanced tasks, the Ubuntu command-line interface (CLI) is recommended. The CLI, similar to the disk operating system (DOS) in Windows, is faster and often used in system debugging. The CLI is accessed through a tool called Terminal, which can be found using the Ubuntu Dash search.

The book then provides a cheat sheet of useful shell commands for working with robots and ROS (Robot Operating System). The 'man' command provides the manual page of a given command, 'ls' lists the content of files and folders in the current directory, 'cd' switches from one folder to another, 'pwd' returns the current path of the terminal, 'mkdir' creates an empty folder, 'rm' deletes a file, 'rmdir' deletes an empty folder, 'mv' moves a file from one location to another and renames the file, 'cp' copies files from one location to another, 'dmesg' displays the kernel logs for debugging, 'lspci' lists the PCI devices in the PC, and 'lsusb' lists the USB devices in the system.

The book also provides examples of how to use each command, including the syntax and an example of the command in use. For instance, to use the 'man' command, the syntax is 'man <shell command>', and an example is 'man ls'. The book also includes figures to illustrate the output of each command. For example, Figure 1-34 shows the output of the 'ls' command, which lists the files in the current path.",1
